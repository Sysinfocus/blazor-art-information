{
  "topic": "Software Design Patterns",
  "hue": 200,
  "slides": [
  {
    "title": "Abstract Factory",
    "description": "Provides an interface for creating families of related objects without specifying concrete classes. In .NET, it is often used to switch between related implementations such as UI themes or data providers. It promotes consistency among created objects."
  },
  {
    "title": "Factory Method",
    "description": "Defines an interface for creating an object but lets subclasses decide which class to instantiate. In .NET, it is commonly used with inheritance and virtual methods. It helps decouple object creation from usage."
  },
  {
    "title": "Builder",
    "description": "Separates the construction of a complex object from its representation. In .NET, it is useful for building complex configuration or request objects step by step. It improves readability and control over object creation."
  },
  {
    "title": "Prototype",
    "description": "Creates new objects by copying an existing instance. In .NET, this is often implemented using cloning or copy constructors. It is useful when object creation is expensive."
  },
  {
    "title": "Singleton",
    "description": "Ensures a class has only one instance and provides a global access point to it. In .NET, it is commonly implemented using static properties and thread-safe initialization. It is useful for shared resources like logging or caching."
  },
  {
    "title": "Adapter",
    "description": "Allows incompatible interfaces to work together by wrapping an existing class. In .NET, adapters are often used to integrate legacy code or third-party libraries. It helps reuse existing functionality without modification."
  },
  {
    "title": "Bridge",
    "description": "Decouples an abstraction from its implementation so both can vary independently. In .NET, it is useful when working with multiple platforms or APIs. It reduces tight coupling between layers."
  },
  {
    "title": "Composite",
    "description": "Composes objects into tree structures to represent part-whole hierarchies. In .NET, it is often used for UI components or hierarchical data. It allows clients to treat individual and composite objects uniformly."
  },
  {
    "title": "Decorator",
    "description": "Adds behavior to objects dynamically without modifying their class. In .NET, it is frequently used with streams or middleware. It promotes flexible and reusable behavior extension."
  },
  {
    "title": "Facade",
    "description": "Provides a simplified interface to a complex subsystem. In .NET, facades are often used to wrap complex libraries or APIs. It improves usability and reduces dependencies."
  },
  {
    "title": "Flyweight",
    "description": "Reduces memory usage by sharing common object state. In .NET, it is useful for handling large numbers of similar objects. It improves performance in memory-intensive scenarios."
  },
  {
    "title": "Proxy",
    "description": "Provides a surrogate or placeholder for another object to control access. In .NET, proxies are used in remoting, lazy loading, or security scenarios. It adds control without changing the target object."
  },
  {
    "title": "Chain Responsibility",
    "description": "Passes a request along a chain of handlers until one handles it. In .NET, it is commonly used in middleware pipelines. It promotes loose coupling between senders and receivers."
  },
  {
    "title": "Command",
    "description": "Encapsulates a request as an object, allowing parameterization and queuing. In .NET, it is often used in UI actions or task scheduling. It supports undo and redo operations."
  },
  {
    "title": "Interpreter",
    "description": "Defines a representation for a language grammar and an interpreter to evaluate sentences. In .NET, it is used for simple scripting or rule engines. It is suitable for small, well-defined languages."
  },
  {
    "title": "Iterator",
    "description": "Provides a way to access elements of a collection sequentially without exposing its structure. In .NET, this is commonly implemented with IEnumerable and IEnumerator. It simplifies traversal logic."
  },
  {
    "title": "Mediator",
    "description": "Defines an object that encapsulates how a set of objects interact. In .NET, it is often used to reduce complex dependencies between components. It centralizes communication logic."
  },
  {
    "title": "Memento",
    "description": "Captures and restores an object's internal state without violating encapsulation. In .NET, it is useful for undo functionality. It helps manage state history safely."
  },
  {
    "title": "Observer",
    "description": "Defines a one-to-many dependency where observers are notified of changes. In .NET, events and delegates are common implementations. It enables reactive and event-driven designs."
  },
  {
    "title": "State",
    "description": "Allows an object to change its behavior when its internal state changes. In .NET, it is used to model state-dependent workflows. It avoids large conditional statements."
  },
  {
    "title": "Strategy",
    "description": "Defines a family of algorithms and makes them interchangeable. In .NET, it is often implemented using interfaces and dependency injection. It enables flexible behavior selection."
  },
  {
    "title": "Template Method",
    "description": "Defines the skeleton of an algorithm while allowing subclasses to override steps. In .NET, it is commonly used in base classes. It promotes code reuse and controlled extensibility."
  },
  {
    "title": "Visitor",
    "description": "Separates algorithms from the objects on which they operate. In .NET, it is useful when performing operations across complex object structures. It allows adding new behavior without modifying existing classes."
  }
]
}
